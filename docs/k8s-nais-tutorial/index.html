
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Kubernetes and NAIS tutorial</title>
  <script src="../bower_components/webcomponentsjs/webcomponents-lite.js"></script>
  <link rel="import" href="../elements/codelab.html">
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <style is="custom-style">
    body {
      font-family: "Roboto",sans-serif;
      background: var(--google-codelab-background, #F8F9FA);
    }
  </style>
  
</head>
<body unresolved class="fullbleed">

  <google-codelab title="Kubernetes and NAIS tutorial"
                  environment="web"
                  feedback-link="">
    
      <google-codelab-step label="About this tutorial" duration="0">
        <p>This tutorial walks you through Kubernetes basics and will introduce you to the features the <a href="https://nais.io" target="_blank">NAIS</a> platform provides you.</p>
<h2>About Kubernetes</h2>
<p><a href="https://kubernetes.io" target="_blank">Kubernetes</a> is a system for deploying and managing containerized applications. Not familiar with containers? Don&#39;t worry, you will learn about it in this tutorial as well.</p>
<h2>About NAIS</h2>
<p>NAIS is <a href="https://nav.no" target="_blank">NAV</a>&#39;s application infrastructure platform built to increase development speed by providing our developers at NAV with the best possible tools to develop and run their applications. The platform based on Kubernetes and provides additional tools and components that our developers might need.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Prerequisites" duration="3">
        <ul>
<li>You must install the <a href="https://cloud.google.com/sdk/docs/downloads-interactive" target="_blank">gcloud-sdk</a> locally on your machine</li>
<li>Access to a NAIS cluster on Google Cloud Platform</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Setup" duration="2">
        <h2>Google Cloud SDK</h2>
<p>Set up the Google Cloud SDK tool:</p>
<pre><code>gcloud init
</code></pre>
<p>When asked about whether to create a new project, say no.<br>Make sure you answer yes when prompted to let the installer modify your profile to update your <code>PATH</code> in order to get gcloud binary directory added to your path.<br>Remember to log in with your @nav adress.</p>
<h2>Kubectl</h2>
<p>We need to install the Kubernetes command line tool <code>kubectl</code>. If you have installed it, skip this step.</p>
<p>Install through the <code>gcloud</code> tool you installed in the first section:</p>
<pre><code>gcloud components install kubectl
</code></pre>
<p>You can also install <code>kubectl</code> using the instructions on the <a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/#install-kubectl" target="_blank">Kubernetes documentation</a>.</p>
<h3>(Optional) Shell autocompletion</h3>
<p>If you want to enable shell autocompletion, you need to run the steps described <a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/#enabling-shell-autocompletion" target="_blank">here</a>.</p>
<h2>Access</h2>
<p>You also need access to the Kubernetes cluster:</p>
<pre><code>gcloud container clusters get-credentials CLUSTER_NAME --zone europe/north1-a --project PROJECT_NAME --account YOUR_EMAIL
</code></pre>
<p>This command will authenticate you against the Kubernetes cluster CLUSTER_NAME.<br>Verify that you have gained access by running:</p>
<pre><code>kubectl get pods
</code></pre>
<p>It might not output anything, but as long as it doesn&#39;t give an error, you are all good.</p>
<p>The command writes to a config file, default <code>$HOME/.kube/config</code>, you can take a look at it if you&#39;re curious.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Run an example app" duration="4">
        <p>In this section we will make a first deployment of a small application. We will use an existing application already wrapped in a Docker image for us.</p>
<h2>Docker</h2>
<p>Kubernetes is a system for deploying, running and managing containerized applications.<br>Docker is a container technology that we can use to wrap an application into an image. You can read more about Docker <a href="https://docker.io..." target="_blank">here</a></p>
<p>Since Kubernetes supports running applications in containers, we need a containereized application for continuing this tutorial.<br>The Docker image we will use is called <code>echoserver</code>. Image url: <code>gcr.io/google-containers/echoserver:1.10</code></p>
<p>Out of the box, Kubernetes will manage your Docker containers, keep track of whether they are healthy or not and how to reach them.</p>
<h2>Run your container</h2>
<p>You can run your container with this command:</p>
<pre><code>kubectl run tutorial-YOUR_NAME --image=gcr.io/google-containers/echoserver:1.9
</code></pre>
<p>This will create your container in a Kubernetes resource that we call pod.<br>Pods are the basic unit for all of the workloads you run on Kubernetes. They usually contain one or more containers, along with an internal IP and specifications on how to run the container(s).<br>Lets take a look at it:</p>
<pre><code>kubectl get pods | grep YOUR_NAME
</code></pre>
<p>You can see the status of your pod, ready containers, restarts and the age of the pod.<br>The pod also has a name, which is the name you specified in the <code>run</code> command above, but in addition it is postfixed by some numbers and letters, which makes sure the pod has an unique name.</p>
<p>Lets take a closer look at the pod we created:</p>
<pre><code>kubectl describe pods INSERT_POD_NAME
</code></pre>
<p>This will list the labels assigned to the pod, the IP, information about the Docker container and image, the state of the container, the status of the Pod and much more information.</p>
<h3>Update the image version</h3>
<p>There is a newer version of our echoserver available, so lets run the new image:</p>
<pre><code>kubectl run tutorial-YOUR_NAME --image=gcr.io/google-containers/echoserver:1.10
</code></pre>
<p>Hmm, error... The deployment already exists. To solve this we could go ahead and delete the Pod:</p>
<pre><code>kubectl delete pod INSERT_POD_NAME
</code></pre>
<p>That worked out nicely. Lets verify that it is deleted:</p>
<pre><code>kubectl get pods | grep YOUR_NAME
</code></pre>
<p>Does the output list two Pods? One with the status Terminating (expected, since we deleted it), but also one that is in a state of <code>Init</code>, <code>PodInitializing</code> or <code>Running</code>?<br>This brings us to another Kubernetes resource type, called RecplicaSet. The ReplicaSet holds our desired state of the application and its job is to make sure we have Pods running according to that state.<br>So when we delete a Pod, it will create a new one according to the same specification. Take a look at the ReplicaSet:</p>
<pre><code>kubectl get replicaset | grep YOUR_NAME
</code></pre>
<p>It outputs along with its age, how many desired, current and ready Pods it has. Take a closer look at its name. The letters and numbers after the name you chose is the same as the first one in the Pod name.</p>
<p>Perhaps we could delete the ReplicaSet, then, before creating the new container? That will not work either.<br>Remember the output from run command in the beginning of this section, <code>deployment &#34;echoserver-YOUR_NAME&#34; created</code>? The ReplicaSet is controlled by a third Kubernetes resource called Deployment.</p>
<pre><code>kubectl get deployment | grep YOUR_NAME
</code></pre>
<p>The Deployment will recreate the ReplicaSet if we delete it. What we could do is to delete the deployment. But our original intention was not to delete the app, it was to update it.<br>Deleting the deployment will result in down time for our users. So lets look at alternatives.</p>
<p>First of all, open a new terminal window and run this command to watch your pod:</p>
<pre><code>kubectl get pods --watch | grep YOUR_NAME
</code></pre>
<p>Keep this terminal window open, and preferably visible next to the other terminal window.</p>
<p>It is possible to edit the Deployment. In the first terminal window, run:</p>
<pre><code>kubectl edit deploy tutorial-YOUR_NAME

</code></pre>
<p>This will open your default editor, describing the deployment in the YAML format. Navigate to the field <code>spec.template.spec.containers.image</code> and insert the image name <code>gcr.io/google-containers/echoserver:1.10</code>.</p>
<p>In terminal window watching the pods, you will see that old pod is terminating at once, while the new ones are initializing. This means that we did not achieve update without the application being down.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Kubernetes deployment" duration="5">
        <p>The Pod is the resource where our containerized application is running. It receives traffic and we can inspect its runtime status and health, along other things. It is managed and controlled by its ReplicaSet.</p>
<p>The ReplicaSet contains the desired state for the application, and that specification is immutable. We cannot update this information. The Deployment controls the ReplicaSet and we can edit the specification here.</p>
<p>Lets first take a look at the Deployment:</p>
<pre><code>kubectl describe deployment tutorial-YOUR_NAME
</code></pre>
<p>...</p>
<p>Normally we let Kubernetes manage the pods for us, so instead we will create the resource Deployment. This resource will manage our application pods.<br>The resource contains information about what Docker image to spin up in a container, environment variables and all the information Kubernetes needs to create a pod for your app.<br>The deployment also holds information of the desired number of pods you want running.</p>
<h2>Create a deployment</h2>
<p>Lets create a deployment. Open the file <code>deployment.yaml</code> in the repository you cloned.</p>
<p>In this yaml file, we will describe the desired state for our application. For example, you can see that the field <code>replicas</code> is set to <code>3</code>. This means that we want 3 pods for this application running.</p>
<p>We need to add more information, so lets go ahead and add our Docker image.</p>
<pre><code>    spec:
      containers:
      - name: app-container
        image: INSERT_IMAGE_HERE
</code></pre>
<p>Set the field <code>spec.template.spec.containers.image</code> to <code>gcr.io/google-containers/echoserver:1.10</code>.</p>
<p>Replicas: 3</p>
<p>We also need to set some metadata and labels:</p>
<ul>
<li>Set <code>metadata.name</code> to a what ever you want to name your app<br>This is the name for the Kubernetes resources created when you apply this file in a cluster.</li>
<li>Set <code>metadata.labels.app</code> to for example <code>yourname-app</code>.<br>This label will</li>
<li>Set the same app label to the fields<code>spec.selector.matchLabels.app</code> and <code>spec.template.metadata.labels</code></li>
</ul>
<p>On the last line in the file, you see that we have set the <code>containerPort</code> to <code>80</code>, which will open that port on the Pod so that we can send traffic to the container.</p>
<p>Apply the file:</p>
<pre><code>kubectl apply -f deployment.yaml
</code></pre>
<p>And watch the update of the Pods:</p>
<pre><code>kubectl get pods --watch | grep YOUR_NAME
</code></pre>
<p>Notice that the new Pods have names with different IDs.</p>
<h2>Health checks</h2>
<p>// helsesjekk, 1 replica = ikke nedefri deployment, neste 3 replicas. Videre til services, så vi veit hvilken ip vi skal gå mot</p>


      </google-codelab-step>
    
      <google-codelab-step label="Kubernetes service" duration="3">
        <p>Run the command to list pods, but this time add the flag <code>-o wide</code> in order to get more information:</p>
<pre><code>kubectl get pods -o wide | grep YOUR_NAME
</code></pre>
<p>Notice that the Pods have an internal IP and hopefully the status <code>Running</code>.</p>
<p>One of the features of a Pod, is that it is mortal, which also means that we cannot rely on the IP address.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Ingress" duration="0">
        

      </google-codelab-step>
    
      <google-codelab-step label="Inspect your app" duration="0">
        

      </google-codelab-step>
    
      <google-codelab-step label="NAIS" duration="5">
        

      </google-codelab-step>
    
      <google-codelab-step label="Logging and metrics" duration="0">
        

      </google-codelab-step>
    
      <google-codelab-step label="Clean-up" duration="0">
        <p>Duration 1:00</p>


      </google-codelab-step>
    
      <google-codelab-step label="Further reading" duration="0">
        <p>Check out the NAIS documentation at <a href="https://nais.io/doc" target="_blank">https://nais.io/doc</a> and the Kubernetes documentation over at <a href="https://kubernetes.io/docs/" target="_blank">https://kubernetes.io/docs/</a>.</p>
<p>We can also recommend <a href="https://www.youtube.com/watch?v=4ht22ReBjno" target="_blank">the illustrated childrens guide to Kubernetes</a>.</p>


      </google-codelab-step>
    
  </google-codelab>

  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-49880327-14', 'auto');

    (function() {
      var gaCodelab = '';
      if (gaCodelab) {
        ga('create', gaCodelab, 'auto', {name: 'codelab'});
      }

      var gaView;
      var parts = location.search.substring(1).split('&');
      for (var i = 0; i < parts.length; i++) {
        var param = parts[i].split('=');
        if (param[0] === 'viewga') {
          gaView = param[1];
          break;
        }
      }
      if (gaView && gaView !== gaCodelab) {
        ga('create', gaView, 'auto', {name: 'view'});
      }
    })();
  </script>

</body>
</html>
