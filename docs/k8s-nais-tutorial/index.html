
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Kubernetes and NAIS tutorial</title>
  <script src="../bower_components/webcomponentsjs/webcomponents-lite.js"></script>
  <link rel="import" href="../elements/codelab.html">
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <style is="custom-style">
    body {
      font-family: "Roboto",sans-serif;
      background: var(--google-codelab-background, #F8F9FA);
    }
  </style>
  
</head>
<body unresolved class="fullbleed">

  <google-codelab title="Kubernetes and NAIS tutorial"
                  environment="web"
                  feedback-link="">
    
      <google-codelab-step label="About this tutorial" duration="0">
        <p>This tutorial walks you through Kubernetes basics and will introduce you to the features that the NAIS platform provides<br>you.</p>
<h2>Kubernetes</h2>
<p><a href="https://kubernetes.io" target="_blank">Kubernetes</a> is a system for deploying and managing containerized applications.</p>
<h2>NAIS</h2>
<p><a href="https://nais.io" target="_blank">NAIS</a> is <a href="https://nav.no" target="_blank">NAV</a>&#39;s application infrastructure platform built to increase development speed by providing our developers at NAV with the best possible tools to develop and run their applications. The platform is  based on Kubernetes and provides additional tools and components that our developers might need.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Prerequisites" duration="15">
        <ul>
<li>You must install the <a href="https://cloud.google.com/sdk/docs/downloads-interactive" target="_blank">gcloud-sdk</a> locally on your machine</li>
<li>Access to a NAIS cluster on Google Cloud Platform</li>
</ul>
<h2>Setup</h2>
<h3>Google Cloud SDK</h3>
<p>Set up the Google Cloud SDK tool:</p>
<pre><code>gcloud init
</code></pre>
<p>When asked about whether to create a new project, say no.<br>Make sure you answer yes when prompted to let the installer modify your profile to update your <code>PATH</code> in order to get gcloud binary directory added to your path.  Remember to log in with your @nav adress.</p>
<h3>Kubectl</h3>
<p>We need to install the Kubernetes command line tool <code>kubectl</code>. If you have installed it, skip this step.<br>Install through the <code>gcloud</code> tool you installed in the first section:</p>
<pre><code>gcloud components install kubectl
</code></pre>
<p>Verify gcloud kubectl is properly installed by issuing <code>kubectl version</code>. Output should be something like:</p>
<pre><code>$ kubectl version
Client Version: version.Info{Major:&#34;1&#34;, Minor:&#34;13&#34;, GitVersion:&#34;v1.13.0&#34;, GitCommit:&#34;ddf47ac13c1a9483ea035a79cd7c10005ff21a6d&#34;, GitTreeState:&#34;clean&#34;, BuildDate:&#34;2018-12-03T21:04:45Z&#34;, GoVersion:&#34;go1.11.2&#34;, Compiler:&#34;gc&#34;, Platform:&#34;darwin/amd64&#34;}
The connection to the server localhost:8080 was refused - did you specify the right host or port?
</code></pre>
<p>Don&#39;t worry about the second line, it just means that we&#39;ve not connected to a cluster yet.<br>You can also install <code>kubectl</code> using the instructions on the <a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/#install-kubectl" target="_blank">Kubernetes documentation</a>.</p>
<h3>(Optional) Shell autocompletion</h3>
<p>If you want to enable shell autocompletion, you need to run the steps described <a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/#enabling-shell-autocompletion" target="_blank">here</a>.</p>
<h3>Access</h3>
<p>You also need access to the Kubernetes cluster:</p>
<pre><code>gcloud container clusters get-credentials CLUSTER_NAME --zone europe/north1-a --project PROJECT_NAME --account YOUR_EMAIL
</code></pre>
<p>This command will authenticate you against the Kubernetes cluster CLUSTER_NAME.<br>Verify that you have gained access by running:</p>
<pre><code>kubectl get pods
</code></pre>
<p>It might not output anything, but as long as it doesn&#39;t give an error, you are all good.</p>
<p>The command writes to a config file, default <code>$HOME/.kube/config</code>, you can take a look at it if you&#39;re curious.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Technologies" duration="2">
        <h2>Docker</h2>
<p>Docker is a technology that allows us to package an application with it&#39;s requirements and basic operating system into a container. Read<br>more <a href="https://www.docker.com/resources/what-container" target="_blank">here</a>.  As this tutorials primary focus is kubernetes (which orchestrates<br>containers), we will not dive deeper into Docker, but rather use an already existing docker image called echoserver. Echoserver is a simple<br>web app that responds with some metadata about it&#39;s host and a few key request headers.<br>Echoserver image url: <code>gcr.io/google-containers/echoserver</code></p>
<h2>Kubernetes</h2>
<p>Kubernetes is an open-source system for automating deployment, scaling, and management of containerized applications.  It groups containers that make up an application into logical units for easy management and discovery. Kubernetes builds upon 15 years of experience of running production workloads at Google, combined with best-of-breed ideas and practices from the community.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Running your first application" duration="10">
        <p>In this section we will make a pod. We will use an existing application that&#39;s already Dockerized for us.</p>
<p>A <a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/explore/explore-intro/#kubernetes-pods" target="_blank">pod</a> is a Kubernetes abstraction that<br>represents a group of one or more application containers, and some shared resources for those containers. Those resources include:</p>
<ul>
<li>Shared storage, as Volumes</li>
<li>Networking, as a unique cluster IP address</li>
<li>Information about how to run each container, such as the container image version or specific ports to use</li>
</ul>
<h2>Creating your first pod</h2>
<p>As we will create multiple files in the tutorial we suggest making a directory <code>$HOME/workshop</code> where you can store your files as you work<br>on them.</p>
<p>Create a file <code>pod.yaml</code> with the following contents:</p>
<pre><code>apiVersion: v1
kind: Pod
metadata:
  name: &lt;YOUR_NAME&gt;
spec:
  containers:
  - name: echoserver
    image: gcr.io/google-containers/echoserver:1.9
    ports:
    - containerPort: 8080
      protocol: TCP
</code></pre>
<p>And run <code>kubectl apply -f pod.yaml</code></p>
<h2>Checking the status of our new pod</h2>
<pre><code>kubectl get pod &lt;YOUR_NAME&gt;
</code></pre>
<p>You can see the status of your pod, ready containers, restarts and the age of the pod.</p>
<p>Lets take a closer look at the pod we created:</p>
<pre><code>kubectl describe pod &lt;YOUR_NAME&gt;
</code></pre>
<p>This will list more detailed information about this pod like its labels and the state of the container.</p>
<h2>Upgrading your application</h2>
<p>There is a newer version of echoserver available, so lets run the new image:</p>
<p>Edit the <code>pod.yaml</code> file we created earlier, setting the <code>image</code> field to <code>gcr.io/google-containers/echoserver:1.10</code> resulting in the<br>following contents:</p>
<pre><code>apiVersion: v1
kind: Pod
metadata:
  name: &lt;YOUR_NAME&gt;
spec:
  containers:
  - name: echoserver
    image: gcr.io/google-containers/echoserver:1.10
    ports:
    - containerPort: 8080
      protocol: TCP
</code></pre>
<p>Then run <code>kubectl apply -f pod.yaml</code></p>
<p>Lets verify that it is updated:</p>
<pre><code>kubectl describe pod &lt;YOUR_NAME&gt;
</code></pre>
<p>and look for the <code>Image</code> field and verify it&#39;s value is now <code>gcr.io/google-containers/echoserver:1.10</code></p>
<h2>Summary</h2>
<p>In this chapter we&#39;ve created, looked at, and updated a pod. The downside with using pods like we&#39;ve just done is that a pod is bound to a specific server in the cluster and also won&#39;t be able to scale horizontally. In the next chapter, we&#39;ll take a close look at <em>Deployments</em>, which solves these issues.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Deployment" duration="10">
        <p>Deployments are one of the most central parts in kubernetes.</p>
<h2>Delete old pod</h2>
<p>Delete your old pod:</p>
<pre><code>kubectl delete pod &lt;YOUR_NAME&gt;
</code></pre>
<h2>Create deployment</h2>
<p>Deployment is the most common way of running X copies (Pods) of your application. And it supports rolling updates to your container images.<br>The resource contains information about what Docker image to spin up in a container, environment variables and all the information Kubernetes needs to create a pod for your app.</p>
<p>Create a deployment like this <code>deployment.yaml</code>:</p>
<pre><code>apiVersion: apps/v1
kind: Deployment
metadata:
  name: &lt;YOUR_NAME&gt;
spec:
  replicas: 1
  selector:
    matchLabels:
      app: &lt;YOUR_NAME&gt;
  template:
    metadata:
      labels:
        app: &lt;YOUR_NAME&gt;
    spec:
      containers:
      - name: nais-testapp
        image: gcr.io/google-containers/echoserver:1.10
        ports:
        - containerPort: 8080
          protocol: TCP
</code></pre>
<p>Let&#39;s go through some of the fields in this resource.<br><code>spec.template</code> this is the same as the previous pod spec<br><code>spec.replcas</code> number of pods to run<br><code>spec.selector</code> which pods this deployment manages</p>
<p>You might also have noticed that the <code>spec.template.metadata</code> does not contain a <code>.name</code> field any more, but instead a <code>metadata.labels.app: &lt;YOUR_NAME</code>. The reason for this is that the pods this Deployment creates will have unique names, and therefore we need some other mechanism to keep track of this deployments pods.</p>
<p>Let&#39;s apply it and see what happend:</p>
<pre><code>kubectl apply -f deployment.yaml
kubectl get pod -l app=&lt;YOUR_NAME&gt; # Uses label selector to get the pods labeled with app=&lt;YOUR_NAME&gt;
</code></pre>
<p>There are a lot of features not covered in this tutorial, but you should check out the <a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" target="_blank">Deployment documentation</a></p>


      </google-codelab-step>
    
      <google-codelab-step label="Connectivity" duration="0">
        <p>The echoserver is an application meant to respond to HTTP requests. Our application is not currently configured for reliable or redundant communication. While it is possible to communicate with it using the POD&#39;s IP address and the containers port (in some network configurations) this is not the recommended way because:</p>
<ul>
<li>a pods IP is not not static</li>
<li>you won&#39;t be able to load balance</li>
<li>you get a new pod IP change every time a new POD is created</li>
</ul>
<p>The way kubernetes solves this is by using <a href="https://kubernetes.io/docs/concepts/services-networking/service/" target="_blank">services</a></p>
<h2>Service</h2>
<p>A Kubernetes Service is an abstraction which defines a logical set of Pods and a policy by which to access them - sometimes called a micro-service. The set of Pods targeted by a Service is (usually) determined by a Label Selector.</p>
<h3>Creating a Service</h3>
<p>To make our echoserver availble inside the cluster we would create a <code>service.yaml</code> file like this:</p>
<pre><code>apiVersion: v1
kind: Service
metadata:
  name: &lt;YOUR_NAME&gt;
spec:
  type: ClusterIP
  ports:
  - port: 80
    protocol: TCP
    targetPort: 8080
  selector:
    app: &lt;YOUR_NAME&gt;
</code></pre>
<p>This makes it possible for other apps in the cluster to communicate with our app using <code>http://&lt;YOUR_NAME/</code>.</p>
<h2>Service discovery</h2>
<p>Every service in kubernetes can be addressed using the service name (<code>&lt;YOUR_NAME&gt;</code>), using the service + namespace (<code>service.namespace</code>), or by using the fully qualified cluster dns (usually <code>service.namespace.svc.cluster.local</code>)</p>
<h2>Ingress</h2>
<p>The <a href="https://kubernetes.io/docs/concepts/services-networking/ingress/" target="_blank">Ingress</a> resource manages external access to the services in a cluster, typically HTTP.</p>
<h3>Create ingress</h3>
<p>Create a file <code>ingress.yaml</code> with the following contents:</p>
<pre><code>apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  annotations:
  name: &lt;YOUR_NAME&gt;
spec:
  rules:
  - host: &lt;YOUR_NAME&gt;.demo.dev-gke.nais.io
    http:
      paths:
      - backend:
          serviceName: &lt;YOUR_NAME&gt;
          servicePort: 80
        path: /
</code></pre>
<p>Notice that we target a service by name here, not labels.</p>
<p>apply it <code>kubectl apply -f ingress.yaml</code></p>
<p>This should enable you to access your echoserver using the following address: <code>https://&lt;YOUR_NAME&gt;.demo.dev-gke.nais.io</code>, try it out:</p>
<pre><code>curl https://&lt;YOUR_NAME&gt;.demo.dev-gke.nais.io
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Rolling update" duration="5">
        <p>Let&#39;s say we wanted to set an environment variable in our pods, but don&#39;t want to interrupt the availability of our app.<br>// Update<br>In terminal window watching the pods, you will see that old pod is terminating at once, while the new ones are initializing. This means that we did not achieve update without the application being down. Keep this window open.</p>
<p>In the previous section, we managed to run our application on Kubernetes, and while thats good and all, we need a more robust way to deploy an application.</p>
<pre><code>kubectl describe deployment tutorial-YOUR_NAME
</code></pre>
<h2>Write the configuration file</h2>
<p>The first time we deployed the application on Kubernetes, we used the <code>kubectl run</code> command. This time we will write a configuration file which we will apply in the cluster.</p>
<p>Create a file with the name <code>deployment.yaml</code>.</p>
<p>In this yaml file, we will describe the desired state for our application.</p>
<pre><code>apiVersion: apps/v1
kind: Deployment
metadata:
  name: NAME
spec:
  replicas: NUMBER_OF_COPIES
  selector:
    matchLabels:
      app: MATCH_LABEL
  template:
    metadata:
      labels:
        app: MATCH_LABEL
    spec:
      containers:
      - name: CONTAINER_NAME
        image: DOCKER_IMAGE
        ports:
        - containerPort: CONTAINER_PORT
</code></pre>
<p>We need to add more information, so lets go ahead and add our Docker image.<br>Set the field <code>spec.template.spec.containers.image</code> to <code>gcr.io/google-containers/echoserver:1.10</code>.</p>
<p>Replicas: 3</p>
<p>We also need to set some metadata and labels:</p>
<ul>
<li>Set <code>metadata.name</code> to a what ever you want to name your app<br>This is the name for the Kubernetes resources created when you apply this file in a cluster.</li>
<li>Set <code>metadata.labels.app</code> to for example <code>yourname-app</code>.<br>This label will</li>
<li>Set the same app label to the fields<code>spec.selector.matchLabels.app</code> and <code>spec.template.metadata.labels</code></li>
</ul>
<p>On the last line in the file, you see that we have set the <code>containerPort</code> to <code>80</code>, which will open that port on the Pod so that we can send traffic to the container.</p>
<p>Apply the file:</p>
<pre><code>kubectl apply -f deployment.yaml
</code></pre>
<p>And watch the update of the Pods in the other terminal window.</p>
<p>Notice that the new Pods have names with different IDs.</p>
<p>// Inspect the replicasets to see that that the deployment created a new one</p>
<h2>Health checks</h2>
<p>// helsesjekk, 1 replica = ikke nedefri deployment, neste 3 replicas. Videre til services, så vi veit hvilken ip vi skal gå mot</p>


      </google-codelab-step>
    
      <google-codelab-step label="Kubernetes service" duration="3">
        <p>Run the command to list pods, but this time add the flag <code>-o wide</code> in order to get more information:</p>
<pre><code>kubectl get pods -o wide | grep YOUR_NAME
</code></pre>
<p>Notice that the Pods have an internal IP and hopefully the status <code>Running</code>.</p>
<p>One of the features of a Pod, is that it is mortal, which also means that we cannot rely on the IP address.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Ingress" duration="0">
        

      </google-codelab-step>
    
      <google-codelab-step label="Inspect your app" duration="0">
        

      </google-codelab-step>
    
      <google-codelab-step label="NAIS" duration="5">
        

      </google-codelab-step>
    
      <google-codelab-step label="Logging and metrics" duration="0">
        

      </google-codelab-step>
    
      <google-codelab-step label="Clean-up" duration="0">
        <p>Duration 1:00</p>


      </google-codelab-step>
    
      <google-codelab-step label="Further reading" duration="0">
        <p>Check out the NAIS documentation at <a href="https://nais.io/doc" target="_blank">https://nais.io/doc</a> and the Kubernetes documentation over at <a href="https://kubernetes.io/docs/" target="_blank">https://kubernetes.io/docs/</a>.</p>
<p>We can also recommend <a href="https://www.youtube.com/watch?v=4ht22ReBjno" target="_blank">the illustrated childrens guide to Kubernetes</a>.</p>


      </google-codelab-step>
    
  </google-codelab>

  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-49880327-14', 'auto');

    (function() {
      var gaCodelab = '';
      if (gaCodelab) {
        ga('create', gaCodelab, 'auto', {name: 'codelab'});
      }

      var gaView;
      var parts = location.search.substring(1).split('&');
      for (var i = 0; i < parts.length; i++) {
        var param = parts[i].split('=');
        if (param[0] === 'viewga') {
          gaView = param[1];
          break;
        }
      }
      if (gaView && gaView !== gaCodelab) {
        ga('create', gaView, 'auto', {name: 'view'});
      }
    })();
  </script>

</body>
</html>
