
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Kubernetes and NAIS tutorial</title>
  <script src="../bower_components/webcomponentsjs/webcomponents-lite.js"></script>
  <link rel="import" href="../elements/codelab.html">
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <style is="custom-style">
    body {
      font-family: "Roboto",sans-serif;
      background: var(--google-codelab-background, #F8F9FA);
    }
  </style>
  
</head>
<body unresolved class="fullbleed">

  <google-codelab title="Kubernetes and NAIS tutorial"
                  environment="web"
                  feedback-link="">
    
      <google-codelab-step label="About this tutorial" duration="0">
        <p>This tutorial walks you through Kubernetes basics and will introduce you to the features that the NAIS platform provides<br>you.</p>
<h2>Kubernetes</h2>
<p><a href="https://kubernetes.io" target="_blank">Kubernetes</a> is a system for deploying and managing containerized applications.</p>
<h2>NAIS</h2>
<p><a href="https://nais.io" target="_blank">NAIS</a> is <a href="https://nav.no" target="_blank">NAV</a>&#39;s application infrastructure platform built to increase development speed by providing our developers at NAV with the best possible tools to develop and run their applications. The platform is  based on Kubernetes and provides additional tools and components that our developers might need.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Prerequisites" duration="15">
        <ul>
<li>You must install the <a href="https://cloud.google.com/sdk/docs/downloads-interactive" target="_blank">gcloud-sdk</a> locally on your machine</li>
<li>Access to a NAIS cluster on Google Cloud Platform</li>
</ul>
<h2>Setup</h2>
<h3>Google Cloud SDK</h3>
<p>Set up the Google Cloud SDK tool:</p>
<pre><code>gcloud auth activate-service-account --key-file=sa.json
gcloud config set compute/region europe-north1
gcloud config set compute/zone europe-north1-a
gcloud config set core/project nais-dev-gke
</code></pre>
<h3>Kubectl</h3>
<p>We need to install the Kubernetes command line tool <code>kubectl</code>. If you have installed it, skip this step.<br>Install through the <code>gcloud</code> tool you installed in the first section:</p>
<pre><code>gcloud components install kubectl
</code></pre>
<p>Verify gcloud kubectl is properly installed by issuing <code>kubectl version</code>. Output should be something like:</p>
<pre><code>$ kubectl version
Client Version: version.Info{Major:&#34;1&#34;, Minor:&#34;13&#34;, GitVersion:&#34;v1.13.0&#34;, GitCommit:&#34;ddf47ac13c1a9483ea035a79cd7c10005ff21a6d&#34;, GitTreeState:&#34;clean&#34;, BuildDate:&#34;2018-12-03T21:04:45Z&#34;, GoVersion:&#34;go1.11.2&#34;, Compiler:&#34;gc&#34;, Platform:&#34;darwin/amd64&#34;}
The connection to the server localhost:8080 was refused - did you specify the right host or port?
</code></pre>
<p>Don&#39;t worry about the second line, it just means that we&#39;ve not connected to a cluster yet.<br>You can also install <code>kubectl</code> using the instructions on the <a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/#install-kubectl" target="_blank">Kubernetes documentation</a>.</p>
<h3>(Optional) Shell autocompletion</h3>
<p>If you want to enable shell autocompletion, you need to run the steps described <a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/#enabling-shell-autocompletion" target="_blank">here</a>.</p>
<h3>Access</h3>
<p>You also need access to the Kubernetes cluster:</p>
<pre><code>gcloud container clusters get-credentials nais-dev
</code></pre>
<p>This command will authenticate you against the Kubernetes cluster <code>nais-dev</code>.<br>Verify that you have gained access by running:</p>
<pre><code>kubectl get pods
</code></pre>
<p>It might not output anything, but as long as it doesn&#39;t give an error, you are all good.</p>
<p>The command writes to a config file, default <code>$HOME/.kube/config</code>, you can take a look at it if you&#39;re curious.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Technologies" duration="2">
        <h2>Docker</h2>
<p>Docker is a technology that allows us to package an application with it&#39;s requirements and basic operating system into a container. Read<br>more <a href="https://www.docker.com/resources/what-container" target="_blank">here</a>.  As this tutorials primary focus is kubernetes (which orchestrates<br>containers), we will not dive deeper into Docker, but rather use an already existing docker image called echoserver. Echoserver is a simple<br>web app that responds with some metadata about it&#39;s host and a few key request headers.<br>Echoserver image url: <code>gcr.io/google-containers/echoserver</code></p>
<h2>Kubernetes</h2>
<p>Kubernetes is an open-source system for automating deployment, scaling, and management of containerized applications.  It groups containers that make up an application into logical units for easy management and discovery. Kubernetes builds upon 15 years of experience of running production workloads at Google, combined with best-of-breed ideas and practices from the community.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Pod" duration="10">
        <p>In this section we will make a Pod. We will use an existing application that&#39;s already Dockerized for us.</p>
<p>A <a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/explore/explore-intro/#kubernetes-pods" target="_blank">Pod</a> is a Kubernetes abstraction that<br>represents a group of one or more application containers, and some shared resources for those containers. Those resources include:</p>
<ul>
<li>Shared storage, as Volumes</li>
<li>Networking, as a unique cluster IP address</li>
<li>Information about how to run each container, such as the container image version or specific ports to use</li>
</ul>
<h2>Creating your first Pod</h2>
<p>As we will create multiple files in the tutorial we suggest making a directory <code>$HOME/workshop</code> where you can store your files as you work<br>on them.</p>
<p>Create a file <code>pod.yaml</code> with the following contents:</p>
<pre><code>apiVersion: v1
kind: Pod
metadata:
  name: &lt;YOUR_APP&gt;
spec:
  containers:
  - name: echoserver
    image: gcr.io/google-containers/echoserver:1.9
    ports:
    - containerPort: 8080
      protocol: TCP
</code></pre>
<p>And run <code>kubectl apply -f pod.yaml</code></p>
<h2>Checking the status of our new Pod</h2>
<pre><code>kubectl get pod &lt;YOUR_APP&gt;
</code></pre>
<p>You can see the status of your Pod, ready containers, restarts and the age of the Pod.</p>
<p>Lets take a closer look at the Pod we created:</p>
<pre><code>kubectl describe pod &lt;YOUR_APP&gt;
</code></pre>
<p>This will list more detailed information about this Pod like its labels and the state of the container.</p>
<h2>Upgrading your application</h2>
<p>There is a newer version of echoserver available, so lets run the new image:</p>
<p>Edit the <code>pod.yaml</code> file we created earlier, setting the <code>image</code> field to <code>gcr.io/google-containers/echoserver:1.10</code> resulting in the<br>following contents:</p>
<pre><code>apiVersion: v1
kind: Pod
metadata:
  name: &lt;YOUR_APP&gt;
spec:
  containers:
  - name: echoserver
    image: gcr.io/google-containers/echoserver:1.10
    ports:
    - containerPort: 8080
      protocol: TCP
</code></pre>
<p>Then run <code>kubectl apply -f pod.yaml</code></p>
<p>Lets verify that it is updated:</p>
<pre><code>kubectl describe pod &lt;YOUR_APP&gt;
</code></pre>
<p>and look for the <code>Image</code> field and verify it&#39;s value is now <code>gcr.io/google-containers/echoserver:1.10</code></p>
<h2>Summary</h2>
<p>In this chapter we&#39;ve created, looked at, and updated a Pod. The downside with using pods like we&#39;ve just done is that a Pod is bound to a specific server in the cluster,  won&#39;t be able to scale horizontally, and the fact that Pods are <em>mortal</em>, meaning they can die. In the next chapter, we&#39;ll take a close look at <em>Deployments</em>, which solves all of these issues.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Deployment" duration="10">
        <p>Deployments are the most common way of running Pods of your application. And it supports features like rolling updates, scaling and more.<br>The resource contains information about what Docker image to spin up in a container, environment variables and all the information Kubernetes needs to create a Pod for your app.</p>
<h2>Delete old Pod</h2>
<p>Delete your old Pod:</p>
<pre><code>kubectl delete pod &lt;YOUR_APP&gt;
</code></pre>
<h2>Create deployment</h2>
<p>Create a deployment like this <code>deployment.yaml</code>:</p>
<pre><code>apiVersion: apps/v1
kind: Deployment
metadata:
  name: &lt;YOUR_APP&gt;
spec:
  replicas: 1
  selector:
    matchLabels:
      app: &lt;YOUR_APP&gt;
  template:
    metadata:
      labels:
        app: &lt;YOUR_APP&gt;
    spec:
      containers:
      - name: nais-testapp
        image: gcr.io/google-containers/echoserver:1.10
        ports:
        - containerPort: 8080
          protocol: TCP
</code></pre>
<p>Let&#39;s go through some of the fields in this resource.<br><code>spec.template</code> this is almost the same as the pod we wrote in the previous chapter.<br><code>spec.replicas</code> number of pods to run<br><code>spec.selector</code> which pods this deployment manages</p>
<p>You might also have noticed that the <code>spec.template.metadata</code> does not contain a <code>.name</code> field any more, but instead a <code>metadata.labels.app: &lt;YOUR_APP</code>. The reason for this is that the pods this Deployment creates will have unique, auto-generated names, and therefore we need some other mechanism to keep track of this deployments pods (labels).</p>
<p>Let&#39;s apply it and see what happend:</p>
<pre><code>kubectl apply -f deployment.yaml
kubectl get pod -l app=&lt;YOUR_APP&gt; # Uses label selector to get the pods labeled with app=&lt;YOUR_NAME&gt;
</code></pre>
<p>There are a lot of features not covered in this tutorial, but you should check out the <a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" target="_blank">Deployment documentation</a></p>


      </google-codelab-step>
    
      <google-codelab-step label="Service" duration="0">
        <p>The echoserver is an application meant to respond to HTTP requests. Our application is not currently configured for reliable or redundant communication. While it is possible to communicate with it using the Pod&#39;s IP address and the containers port (in some network configurations) this is not the recommended way because:</p>
<ul>
<li>a pods IP is not not static</li>
<li>you won&#39;t be able to load balance</li>
<li>you get a new Pod IP change every time a new Pod is created</li>
</ul>
<p>The way kubernetes solves this is by using <a href="https://kubernetes.io/docs/concepts/services-networking/service/" target="_blank">services</a></p>
<h2>Service</h2>
<p>A Kubernetes Service is an abstraction which defines a logical set of Pods and a policy by which to access them - sometimes called a micro-service. The set of Pods targeted by a Service is (usually) determined by a Label Selector.</p>
<h3>Creating a Service</h3>
<p>To make our echoserver availble inside the cluster we would create a <code>service.yaml</code> file like this:</p>
<pre><code>apiVersion: v1
kind: Service
metadata:
  name: &lt;YOUR_APP&gt;
spec:
  type: ClusterIP
  ports:
  - port: 80
    protocol: TCP
    targetPort: 8080
  selector:
    app: &lt;YOUR_APP&gt;
</code></pre>
<p>This makes it possible for other apps in the cluster to communicate with our app using <code>http://&lt;YOUR_APP/</code>.</p>
<h2>Service discovery</h2>
<p>Every service in kubernetes can be addressed using the service name (<code>&lt;YOUR_APP&gt;</code>), using the service + namespace (<code>service.namespace</code>), or by using the fully qualified cluster dns (usually <code>service.namespace.svc.cluster.local</code>)</p>


      </google-codelab-step>
    
      <google-codelab-step label="Ingress" duration="0">
        <p>The <a href="https://kubernetes.io/docs/concepts/services-networking/ingress/" target="_blank">Ingress</a> resource manages external access to the services in a cluster, typically HTTP.</p>
<h2>Create ingress</h2>
<p>Create a file <code>ingress.yaml</code> with the following contents:</p>
<pre><code>apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: &lt;YOUR_APP&gt;
spec:
  rules:
  - host: &lt;YOUR_APP&gt;.demo.dev-gke.nais.io
    http:
      paths:
      - backend:
          serviceName: &lt;YOUR_APP&gt;
          servicePort: 80
        path: /
</code></pre>
<p>Notice that we target a service by name here, not labels.</p>
<p>apply it <code>kubectl apply -f ingress.yaml</code></p>
<p>This should enable you to access your echoserver using the following address: <code>https://&lt;YOUR_APP&gt;.demo.dev-gke.nais.io</code>, try it out:</p>
<pre><code>curl http://&lt;YOUR_APP&gt;.demo.dev-gke.nais.io
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Rolling update" duration="5">
        <p>In this chapter we&#39;ll take a look a thow we can roll out updates without interrupting the availability of our app.</p>
<h2>Adding a label</h2>
<p>Let&#39;s say we wanted to add a new label to our pods, let&#39;s give it a try.</p>
<p>In your <code>deployment.yaml</code><br>Set <code>spec.template.metadata.labels.important</code> to <code>obviously</code></p>
<p>The metadata part of the template should something look like this:</p>
<pre><code>  template:
    metadata:
      labels:
        app: &lt;YOUR_APP&gt;
        important: obviously
</code></pre>
<p>Now, apply the deployment: <code>kubectl apply -f deployment.yaml; kubectl get pods -l app=&lt;YOUR_APP&gt;</code><br>You should see two pods, one in the &#34;ContainerCreating&#34; state and one &#34;Running&#34;. This is due to the fact that de default deployment strategy in kubernetes is &#34;RollingUpdate&#34;, you can check this by issuing: <code>kubectl describe deployment &lt;YOUR_APP&gt;</code> and looking at the fields <code>StrategyType</code> and <code>RollingUpdateStrategy</code></p>
<p>If the application you&#39;re running has 0ms startup time, this would be enough for zero downtime updates, however most apps need some time to warm up before they can start serving requests.</p>
<p>Enter Readiness probes.</p>
<h2>Readiness probe</h2>
<p>Modify your <code>deployment.yaml</code> adding a readiness probe</p>
<pre><code>apiVersion: apps/v1
kind: Deployment
metadata:
  name: &lt;YOUR_APP&gt;
spec:
  replicas: 1
  selector:
    matchLabels:
      app: &lt;YOUR_APP&gt;
  template:
    metadata:
      labels:
        app: &lt;YOUR_APP&gt;
    spec:
      containers:
      - name: nais-testapp
        image: gcr.io/google-containers/echoserver:1.10
        ports:
        - containerPort: 8080
          protocol: TCP
        readinessProbe:
          httpGet:
            path: /
            port: 8080
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Scaling" duration="0">
        <pre><code>kubectl scale deployment --replicas 2 &lt;YOUR_APP&gt;
kubectl get pod -l app=&lt;YOUR_APP&gt; # Notice you&#39;ve got 2 pods now.
</code></pre>
<p>Go to https://.demo.dev-gke.nais.io/ and refresh a couple of times, notice how the hostname changes? This is due to the fatc that<br>we&#39;re being load-balanced between our two pods.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Inspect your app" duration="0">
        <h2>Logs</h2>
<p>As long as your app logs to <code>stdout</code> the logs are available by using <code>kubectl logs &lt;POD_NAME&gt;</code></p>


      </google-codelab-step>
    
      <google-codelab-step label="NAIS" duration="5">
        

      </google-codelab-step>
    
      <google-codelab-step label="Logging and metrics" duration="0">
        

      </google-codelab-step>
    
      <google-codelab-step label="Clean-up" duration="0">
        <p>Duration 1:00</p>


      </google-codelab-step>
    
      <google-codelab-step label="Further reading" duration="0">
        <p>Check out the NAIS documentation at <a href="https://nais.io/doc" target="_blank">https://nais.io/doc</a> and the Kubernetes documentation over at <a href="https://kubernetes.io/docs/" target="_blank">https://kubernetes.io/docs/</a>.</p>
<p>We can also recommend <a href="https://www.youtube.com/watch?v=4ht22ReBjno" target="_blank">the illustrated childrens guide to Kubernetes</a>.</p>


      </google-codelab-step>
    
  </google-codelab>

  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-49880327-14', 'auto');

    (function() {
      var gaCodelab = '';
      if (gaCodelab) {
        ga('create', gaCodelab, 'auto', {name: 'codelab'});
      }

      var gaView;
      var parts = location.search.substring(1).split('&');
      for (var i = 0; i < parts.length; i++) {
        var param = parts[i].split('=');
        if (param[0] === 'viewga') {
          gaView = param[1];
          break;
        }
      }
      if (gaView && gaView !== gaCodelab) {
        ga('create', gaView, 'auto', {name: 'view'});
      }
    })();
  </script>

</body>
</html>
